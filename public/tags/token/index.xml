<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Token on My New Hugo Site！！！</title>
    <link>http://localhost:1313/tags/token/</link>
    <description>Recent content in Token on My New Hugo Site！！！</description>
    <generator>Hugo</generator>
    <language>zh-TW</language>
    <lastBuildDate>Fri, 10 Dec 2021 11:35:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/token/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>「Spring Security」基于Redis的Token自动续签优化</title>
      <link>http://localhost:1313/posts/spring-security-token/</link>
      <pubDate>Fri, 10 Dec 2021 11:35:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/spring-security-token/</guid>
      <description>本文基于上一篇文章：《Spring Security（三）整合 JWT 实现无状态登录示例》。&#xA;在 SpringSecurity 整合 JWT 实现无状态登录示例中，我们在 JwtAuthenticationFilter (自定义JWT认证过滤器) 解析 Token 成功后，提供了续签逻辑：&#xA;/** * 刷新Token的时机： * 1. 当前时间 &amp;lt; token过期时间 * 2. 当前时间 &amp;gt; (签发时间 + (token过期时间 - token签发时间)/2) */ private void refreshToken(HttpServletResponse response, Claims claims) { // 当前时间 long current = System.currentTimeMillis(); // token签发时间 long issuedAt = claims.getIssuedAt().getTime(); // token过期时间 long expiration = claims.getExpiration().getTime(); // (当前时间 &amp;lt; token过期时间) &amp;amp;&amp;amp; (当前时间 &amp;gt; (签发时间 + (token过期时间 - token签发时间)/2)) if ((current &amp;lt; expiration) &amp;amp;&amp;amp; (current &amp;gt; (issuedAt + ((expiration - issuedAt) / 2)))) { /* * 重新生成token */ Calendar calendar = Calendar.</description>
    </item>
  </channel>
</rss>
