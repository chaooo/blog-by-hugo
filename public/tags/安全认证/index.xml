<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>安全认证 on My New Hugo Site！！！</title>
    <link>http://localhost:1313/tags/%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81/</link>
    <description>Recent content in 安全认证 on My New Hugo Site！！！</description>
    <generator>Hugo</generator>
    <language>zh-TW</language>
    <lastBuildDate>Thu, 30 Dec 2021 12:28:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>「Spring Security」前后端分离权限控制-指令级权限</title>
      <link>http://localhost:1313/posts/spring-security-permission/</link>
      <pubDate>Thu, 30 Dec 2021 12:28:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/spring-security-permission/</guid>
      <description>实现按钮级别的权限控制，基于上一篇Spring Secuirty（六）前后端分离菜单权限控制-前端动态路由的扩展。 前端部分还是基于vue-element-admin模板来演示。&#xA;这里实现按钮级别的权限判断的逻辑：每个按钮对应一个权限标识，后台根据用户角色计算出当前用户可访问的权限标识列表，前端登录后得到权限标识列表存入全局，通过单个按钮的权限标识去匹配列表里的。来实现按钮级别的权限判断。&#xA;1. 数据库添加权限表 -- 系统权限表 DROP TABLE IF EXISTS `system_permission`; CREATE TABLE `system_permission` ( `id` BIGINT NOT NULL AUTO_INCREMENT COMMENT &amp;#39;ID&amp;#39;, `menu_id` BIGINT NOT NULL COMMENT &amp;#39;菜单ID&amp;#39;, `name` VARCHAR(100) DEFAULT NULL COMMENT &amp;#39;权限标识&amp;#39;, `title` VARCHAR(100) NOT NULL COMMENT &amp;#39;权限名称&amp;#39;, PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=UTF8MB4 COMMENT=&amp;#39;系统权限表&amp;#39;; -- 权限&amp;amp;角色 关联表 DROP TABLE IF EXISTS `system_role_permission`; CREATE TABLE `system_role_permission` ( `id` BIGINT NOT NULL AUTO_INCREMENT, `role_id` BIGINT DEFAULT NULL COMMENT &amp;#39;角色ID&amp;#39;, `permission_id` BIGINT DEFAULT NULL COMMENT &amp;#39;权限ID&amp;#39;, PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=UTF8MB4 COMMENT=&amp;#39;系统角色权限关联表&amp;#39;; 2.</description>
    </item>
    <item>
      <title>「Spring Security」前后端分离菜单权限控制-前端动态路由</title>
      <link>http://localhost:1313/posts/spring-security-vue/</link>
      <pubDate>Mon, 27 Dec 2021 17:35:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/spring-security-vue/</guid>
      <description>前端部分，这里基于vue-element-admin模板来演示， vue-element-admin是一个后台前端解决方案，它基于vue和element-ui实现。&#xA;1. 安装 vue-element-admin # 克隆项目 git clone https://github.com/PanJiaChen/vue-element-admin.git # 进入项目目录 cd vue-element-admin # 安装依赖， 建议不要用 cnpm 安装 会有各种诡异的bug 可以通过如下操作解决 npm 下载速度慢的问题 npm install --registry=https://registry.npm.taobao.org # 本地开发 启动项目 npm run dev 2. 改造前端路由挂载方式 vue-element-admin中权限的实现方式是：通过获取当前用户的权限去比对路由表，生成当前用户具有的权限可访问的路由表，通过router.addRoutes动态挂载到router上。&#xA;这里改造得更灵活一点，后台根据用户计算出可访问得菜单列表，直接返回用户可访问得菜单列表，前端也需要保存一份全的路由表，用户登录后得到可访问菜单，匹配前端保存的路由表然后动态挂载。&#xA;用户登录成功之后，在全局钩子router.beforeEach中拦截路由，判断是否已获得token，在获得token之后我们就要去获取用户的基本信息及可访问菜单，然后动态挂载路由。&#xA;/** * src/permission.js */ // router.beforeEach const hasRoles = store.getters.roles &amp;amp;&amp;amp; store.getters.roles.length &amp;gt; 0 if (hasRoles) { next() } else { // get user info const { menus } = await store.dispatch(&amp;#39;user/getInfo&amp;#39;) // generate accessible routes map based on menus const accessRoutes = await store.</description>
    </item>
    <item>
      <title>「Spring Security」前后端分离后台菜单权限控制</title>
      <link>http://localhost:1313/posts/spring-security-rbac/</link>
      <pubDate>Mon, 13 Dec 2021 14:35:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/spring-security-rbac/</guid>
      <description>1. RBAC权限控制模型 RBAC（Role-based access control）是一种以角色为基础的访问控制（Role-based access control，RBAC），它是一种较新且广为使用的权限控制机制，这种机制不是直接给用户赋予权限，而是将权限赋予角色。&#xA;RBAC 权限模型将用户按角色进行归类，通过用户的角色来确定用户对某项资源是否具备操作权限。RBAC 简化了用户与权限的管理，它将用户与角色关联、角色与权限关联、权限与资源关联，这种模式使得用户的授权管理变得非常简单和易于维护。&#xA;2. 数据库设计 -- 用户表 DROP TABLE IF EXISTS `sys_user`; CREATE TABLE `sys_user` ( `id` BIGINT NOT NULL AUTO_INCREMENT COMMENT &amp;#39;用户ID&amp;#39;, `username` VARCHAR(255) DEFAULT NULL COMMENT &amp;#39;用户名&amp;#39;, `password` VARCHAR(255) DEFAULT NULL COMMENT &amp;#39;密码&amp;#39;, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&amp;#39;用户表&amp;#39;; -- 角色表 DROP TABLE IF EXISTS `sys_role`; CREATE TABLE `sys_role` ( `id` BIGINT NOT NULL AUTO_INCREMENT COMMENT &amp;#39;角色ID&amp;#39;, `role_name` VARCHAR(50) DEFAULT NULL COMMENT &amp;#39;角色名称&amp;#39;, `role_desc` VARCHAR(255) DEFAULT NULL COMMENT &amp;#39;描述&amp;#39;, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&amp;#39;角色表&amp;#39;; -- 菜单表 DROP TABLE IF EXISTS `sys_menu`; CREATE TABLE `sys_menu` ( `id` BIGINT NOT NULL AUTO_INCREMENT COMMENT &amp;#39;菜单ID&amp;#39;, `menu_name` VARCHAR(100) DEFAULT NULL COMMENT &amp;#39;菜单名称&amp;#39;, `menu_path` VARCHAR(255) DEFAULT NULL COMMENT &amp;#39;菜单路径&amp;#39;, `menu_type` char DEFAULT NULL COMMENT &amp;#39;菜单类型(1:一级菜单，2:子菜单，3:按钮)&amp;#39;, `menu_parent_id` BIGINT DEFAULT NULL COMMENT &amp;#39;父级菜单Id&amp;#39;, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&amp;#39;菜单表&amp;#39;; -- 用户&amp;amp;角色 关联表 DROP TABLE IF EXISTS `sys_role_user`; CREATE TABLE `sys_role_user` ( `id` BIGINT NOT NULL AUTO_INCREMENT, `role_id` BIGINT DEFAULT NULL COMMENT &amp;#39;角色ID&amp;#39;, `user_id` BIGINT DEFAULT NULL COMMENT &amp;#39;用户ID&amp;#39;, PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=UTF8MB4 COMMENT=&amp;#39;系统用户角色关联表&amp;#39;; -- 菜单&amp;amp;角色 关联表 DROP TABLE IF EXISTS `sys_role_menu`; CREATE TABLE `sys_role_menu` ( `id` BIGINT NOT NULL AUTO_INCREMENT, `role_id` BIGINT DEFAULT NULL COMMENT &amp;#39;角色ID&amp;#39;, `menu_id` BIGINT DEFAULT NULL COMMENT &amp;#39;菜单ID&amp;#39;, PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=UTF8MB4 COMMENT=&amp;#39;系统角色菜单关联表&amp;#39;; -- 初始数据： -- 管理员拥有所有菜单权限 -- 普通用户拥有查看权限 INSERT INTO `sys_role`(`id`, `role_name`, `role_desc`) VALUES (1, &amp;#39;admin&amp;#39;, &amp;#39;管理员&amp;#39;),(2, &amp;#39;user&amp;#39;, &amp;#39;普通用户&amp;#39;); INSERT INTO `sys_menu`(`id`, `menu_name`,`menu_path`,`menu_type`,`menu_parent_id`) VALUES (1, &amp;#39;用户管理&amp;#39;, &amp;#39;/user&amp;#39;, 1, null), (2, &amp;#39;用户列表&amp;#39;, &amp;#39;/user/list&amp;#39;, 2, 1), (3, &amp;#39;新增用户&amp;#39;, &amp;#39;/user/add&amp;#39;, 2, 1), (4, &amp;#39;修改用户&amp;#39;, &amp;#39;/user/update&amp;#39;, 2, 1), (5, &amp;#39;删除用户&amp;#39;, &amp;#39;/user/delete&amp;#39;, 3, 1); INSERT INTO `sys_role_user`(`user_id`, `role_id`) VALUES (1, 1); INSERT INTO `sys_role_menu`(`role_id`, `menu_id`) VALUES (1, 1),(1, 2),(1, 3),(1, 4),(1, 5), (2, 1),(2, 2); 3.</description>
    </item>
    <item>
      <title>「Spring Security」基于Redis的Token自动续签优化</title>
      <link>http://localhost:1313/posts/spring-security-token/</link>
      <pubDate>Fri, 10 Dec 2021 11:35:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/spring-security-token/</guid>
      <description>本文基于上一篇文章：《Spring Security（三）整合 JWT 实现无状态登录示例》。&#xA;在 SpringSecurity 整合 JWT 实现无状态登录示例中，我们在 JwtAuthenticationFilter (自定义JWT认证过滤器) 解析 Token 成功后，提供了续签逻辑：&#xA;/** * 刷新Token的时机： * 1. 当前时间 &amp;lt; token过期时间 * 2. 当前时间 &amp;gt; (签发时间 + (token过期时间 - token签发时间)/2) */ private void refreshToken(HttpServletResponse response, Claims claims) { // 当前时间 long current = System.currentTimeMillis(); // token签发时间 long issuedAt = claims.getIssuedAt().getTime(); // token过期时间 long expiration = claims.getExpiration().getTime(); // (当前时间 &amp;lt; token过期时间) &amp;amp;&amp;amp; (当前时间 &amp;gt; (签发时间 + (token过期时间 - token签发时间)/2)) if ((current &amp;lt; expiration) &amp;amp;&amp;amp; (current &amp;gt; (issuedAt + ((expiration - issuedAt) / 2)))) { /* * 重新生成token */ Calendar calendar = Calendar.</description>
    </item>
    <item>
      <title>「Spring Security」整合 JWT 实现无状态登录示例</title>
      <link>http://localhost:1313/posts/spring-security-jwt/</link>
      <pubDate>Thu, 09 Dec 2021 16:35:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/spring-security-jwt/</guid>
      <description>JSON Web Token（缩写 JWT）基于JSON格式信息一种Token令牌，是目前最流行的跨域认证解决方案。&#xA;JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户。 此后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。 服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。 1. 依赖与配置文件 在 pom.xml 中引入依赖： &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt; &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.jsonwebtoken&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jjwt&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.9.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2.78&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 用户信息从数据库中获取，在 application.yml 配置文件中配置： server: port: 8080 spring: datasource: url: jdbc:mysql://192.168.2.100:3306/security?characterEncoding=UTF8&amp;amp;serverTimezone=Asia/Shanghai username: developer password: 05bZ/OxTB:X+yd%1 mybatis: mapper-locations: classpath:mapper/*.xml 2. 自定义Security策略 2.</description>
    </item>
    <item>
      <title>「Spring Security」安全架构与认证鉴权原理</title>
      <link>http://localhost:1313/posts/spring-security-filter/</link>
      <pubDate>Mon, 29 Nov 2021 14:01:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/spring-security-filter/</guid>
      <description>1. Spring Security Servlet 安全架构 Spring Security 设计的 Servlet 安全从架构上分为三个层次，分别是「认证」、「鉴权」、「入侵防护」。通过过滤器机制将安全逻辑应用到 Servlet 项目。&#xA;请求的接收和处理是通过一个一个的过滤器顺序执行实现的，过滤器是 Servlet 项目处理请求的基础。&#xA;Spring 将自己体系内的过滤器交由「过滤器代理FilterChainProxy」管理，FilterChainProxy 同样也是一个过滤器，被封装在 Spring 的「过滤器委托代理DelegatingFilterProxy」中。 Spring Security 在 FilterChainProxy 中加入了「安全过滤器链SecurityFilterChain」实现安全保护功能。&#xA;其过程如图： 安全过滤器链（SecurityFilterChain）的特点：&#xA;为所有 Spring Security 支持的 Servlet 指明了起点； 对于一些后台操作，可以提升执行效率； 在 Servlet 容器中，过滤器的选择是由 URL 决定的，如此便可针对不同 URL 指定相互独立的安全策略。 1.1 安全过滤器 Filter Spring Security 内置了 33 种安全过滤器，每个过滤器有固定的顺序及应用场景；内置过滤器的参数设置通过 HttpSecurity 类相应的配置方法完成。&#xA;在认证与授权中关键的三个过滤器：&#xA;UsernamePasswordAuthenticationFilter：该过滤器用于拦截我们表单提交的请求（默认为/login），进行用户的认证过程。 FilterSecurityInterceptor：该过滤器主要用来进行授权判断。 ExceptionTranslationFilter：该过滤器主要用来捕获处理spring security抛出的异常，异常主要来源于FilterSecurityInterceptor。 Spring Security 的认证、授权异常在过滤器校验过程中产生，并在 ExceptionTranslationFilter 中接收并进行处理，&#xA;ExceptionTranslationFilter 过滤器首先像其他过滤器一样，调用过滤器链的执行方法 FilterChain.doFilter(request, response) 启动过滤处理； 如果当前的用户没有通过认证或者因为其他原因在执行过程中抛出了 AuthenticationException 异常，此时将开启「认证流程」： 清空 SecurityContextHolder 对象； 并将原始请求信息「request」保存到 RequestCache 对象中； 使用 AuthenticationEntryPoint 对象存储的认证地址，向客户端索要身份证明。例如，使用浏览器登录的用户，将浏览器地址重定向到 /login 或者回传一个 WWW-Authenticate 认证请求头。 如果当前用户身份信息已确认，但是没有访问权限，则会产生 AccessDeniedException 异常，然后访问被拒绝。继续执行拒绝处理 AccessDeniedHandler。 1.</description>
    </item>
    <item>
      <title>「Spring Security」Spring Security 基础入门示例</title>
      <link>http://localhost:1313/posts/spring-security-base/</link>
      <pubDate>Thu, 25 Nov 2021 15:01:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/spring-security-base/</guid>
      <description>Spring Security 是一个功能强大且高度可定制的身份验证和访问控制的安全框架。它是 Spring 应用程序在安全框架方面的公认标准。&#xA;其核心特性包括：认证和授权、常规攻击防范、与 Servlet 接口集成、与 Spring MVC 集成等。&#xA;常规攻击防范在 Spring Security 安全框架中是默认开启的，常见的威胁抵御方式有：防止伪造跨站请求（CSRF），安全响应头（HTTP Response headers），HTTP通讯安全等&#xA;1. 入门示例 新建 SpringBoot 项目，在 pom.xml 中增加 Spring Security 依赖：&#xA;&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 只要加入依赖，项目的所有接口都会被自动保护起来。&#xA;创建一个 Controller：&#xA;@RestController public class HelloApi { @GetMapping(&amp;#34;/hello&amp;#34;) public String hello() { return &amp;#34;hello&amp;#34;; } } 导入spring-boot-starter-security启动后，Spring Security已经生效，默认拦截全部请求，如果用户没有登录，跳转到内置登录页面。&#xA;访问/hello接口 ，需要登录之后才能访问。&#xA;默认配置下，会自动生成一个 user 用户，并分配其随机密码，密码可以从控制台的日志信息中找到：&#xA;2. Spring Security默认配置项 Spring Boot 引入 Spring Security 启动后，将会自动开启如下配置项：&#xA;默认开启一系列基于 springSecurityFilterChain 的 Servlet 过滤器，包含了几乎所有的安全功能，例如：保护系统 URL、验证用户名、密码表单、重定向到登录界面等； 创建 UserDetailsService 实例，并生成随机密码，用于获取登录用户的信息详情； 将安全过滤器应用到每一个请求上。 除此之外，Spring Security 还有一些其他可配置的功能：</description>
    </item>
  </channel>
</rss>
