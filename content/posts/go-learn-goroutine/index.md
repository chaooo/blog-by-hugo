---
title: Golang -- Go协程 与 通道
date: 2023-08-01 19:28:30
tags: [Go, 后端开发]
categories: [Golang]
series: Golang入门
toc: true
---

- 进程：主要指运行在内存中的应用程序；进程是系统进行资源分配和调度的一个独立单位，一个进程由一个或多个线程组成。
- 线程：线程是进程的一个实体，这些线程共享同一个内存地址空间，线程是`cpu`调度和分派的最小单位。
- 多线程：指在同一程序（一个进程）中有多个顺序流（线程）在执行。
- 并行与并发：
    + 并行：指多个处理器或者是多核的处理器同时处理多个不同的任务（物理上的同时发生）。
    + 并发：通过`cpu`调度算法，一个处理器同时处理多个任务（逻辑上的同时发生）。

  
## Go协程（goroutine）
`Golang`中，应用程序**并发处理**的部分被称作`goroutine`（**Go协程**），由`Go`运行时管理的**轻量级**线程。 它可以进行更有效的并发运算。

在协程和线程并不是一对一的关系：协程是根据一个或多个线程的可用性，映射（多路复用）在他们之上的；协程调度器在`Go`运行时很好的完成了这个工作。

当系统调用（比如等待I/O）阻塞协程时，其他协程会继续在其他线程上工作。协程的设计隐藏了许多线程创建和管理方面的复杂工作。

协程可以运行在多个操作系统线程之间，也可以运行在线程之内，让你可以很小的内存占用就可以处理大量的任务。

使用关键字`go`启动一个协程, 同一个程序中的所有`goroutine`共享同一个地址空间并且分配了独立的栈。
```go
go 函数名( 参数列表 ) // 在当前的计算过程中开始一个同时进行的函数
```

协程的栈会根据需要进行伸缩，不会出现栈溢出；开发者无需关心栈的大小。当协程结束的时候，它会静默退出：用来启动这个协程的函数也不会得到任何的返回值。

任何`Go`程序都必须有的`main()`函数默认是一个协程，尽管它并没有通过`go`来启动。


## 信道/通道（Channel）
**信道**是带有类型的管道，你可以通过它用信道操作符`<-`来发送或者接收值。
```go
ch <- v    // 将 v 发送至信道 ch。
v := <-ch  // 从 ch 接收值并赋予 v。
```
`Golang`有一个特殊的类型，`通道（Channel）`，信道在使用前必须创建：
```go
ch := make(chan int)
```
未初始化的通道的值是`nil`。

默认情况下，通信是同步且无缓冲的：发送端发送数据，同时必须有接收端相应的接收数据。所以**通道的发送/接收操作在对方准备好之前是阻塞的**。


### 带缓冲的信道
信道可以是 带缓冲的。将缓冲长度作为第二个参数提供给 make 来初始化一个带缓冲的信道：
```go
ch := make(chan int, 100)
```
仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。
```go
package main
import "fmt"
func main() {
    // 整数类型的带缓冲通道,缓冲区大小为2
    ch := make(chan int, 2)
    // 可以同时发送2个数据, 而不用立刻需要去同步读取数据
    ch <- 1
    ch <- 2
    // 获取这两个数据
    fmt.Println(<-ch)
    fmt.Println(<-ch)
}
```

### 遍历通道与关闭通道
- 循环 `for i := range ch {}`会不断从信道接收值，直到它被关闭。
- 可以使用逗号，`ok`操作符：用来检测通道是否被关闭。
```go
v, ok := <-ch   // 如果 v 接收到值，则为 ok 为 true
```
- 通道可以通过`close(ch)`显式的关闭，尽管信道与文件不同不必每次都关闭。

```go
package main
import "fmt"
func fibonacci(n int, c chan int) {
    x, y := 0, 1
    for i := 0; i < n; i++ {
        c <- x
        x, y = y, x+y
    }
    close(c)
}
func main() {
    c := make(chan int, 10)
    go fibonacci(cap(c), c)
    // range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个数据之后就关闭了通道，
    // 所以这里我们 range 函数在接收到 10 个数据之后就结束了。
    // 如果上面的 c 通道不关闭，那么 range 函数就不会结束，从而在接收第 11 个数据的时候就阻塞了。
    for i := range c {
      fmt.Printf("%d\t", i)
    }
}
```
运行结果为：
```shell
0	1	1	2	3	5	8	13	21	34
```

### 使用 select 切换协程
`select`选择处理列出的多个通信情况中的一个。如果多个可以处理，随机选择一个。`default`语句是可选的，如果没有通道操作可以处理`default`语句就会执行。
```go
select {
case u:= <- ch1:
        // do something ...
case v:= <- ch2:
        // do something ...
default: // no value ready to be received
        // do default ...
}
```

